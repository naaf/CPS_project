Service    :       Level

Types      :       bool, int, enum Nature{EMPTY, DIRT, METAL}

Observators:       
	const height:[Level] --> int
	const width:[Level] --> int
	editing:[Level] --> bool
	nature:[Level] * int * int --> Nature
	caseExiste:[Level] * int * int --> bool
	
	onExit : [Level] * int * int --> bool    
		pre onExit(L, x, y) require ¬(editing(L))
	entranceX: [Level] --> int 
		pre entrance(L) require ¬(editing(L))
	entranceY: [Level] --> int 
        pre entrance(L) require ¬(editing(L))  
                 		
Constructors:      
	init:int * int --> [Level]
		pre init(n1 , n2) require (n1 > 0)^(n2 > 0)
       
Operators   :       
	setNature:[Level] * int * int * Nature --> [Level]
		pre setNature(L, n1, n2, Nat) require
			caseExiste(L, n1, n2)
			^ editing(L)
		                            
	goPlay:[Level] --> [Level]
		pre goPlay(L) require 
			editing(L) 
			^ (∀ i ∈ {0, height(L) -1} et j ∈ {0 ... width(L) -1} nature(L,i,j) = METAL)
			^ (∀ i ∈ {0 ... height(L) -1} et j ∈ {0 , width(L) -1} nature(L,i,j) = METAL)
			^ ∃ y1,y2,y3 consécutifs  ∈ {1 ... height(L)-1} et ∃x ∈ {1 ... width(L)-1} tq 
				nature(L,x,y1) = nature(L,x,y3) = nature(L,x,y2) = EMPTY  
			^ ∃ y1,y2,y3 consécutifs ∈ {1 à height(L)-1} et ∃ x ∈ {1 à width(L)-1} tq 
				nature(L,x,y3) = METAL ^ nature(L,x,y1) = EMPTY ^ nature(L,x,y2) = EMPTY 
		                                          
	remove:[Level] * int * int --> [Level]
		pre remove(L, n1, n2) require
			¬(editing(L))
			^ caseExiste(n1, n2)
			^ nature(L, n1, n2) = DIRT
		                            
	build:[Level] * int * int --> [Level]     
		pre remove(L, n1, n2) require
			¬(editing(L))
			^ caseExiste(n1, n2)
			^ nature(L, n1, n2) = EMPTY
                            
Observations :
    [invariant]      
		height(L) > 5 
		width(L) > 4
		caseExiste(L, n1, n2) min=  0 <= n1 < height(L) && 0 <= n1 < width(L)
		
           
    
    [init]          
		height(init(n1 , n2)) = n1
		width(init(n1 , n2)) = n2
		editing(init(n1 , n2)) = true
		∀i ∈ {0 ... n1 -1}, ∀j ∈ {0 ... n2 -1} 
			nature(init(n1 , n2), i, j) = EMPTY
         	          
     [setNature]          
		editing(setNature(L, i, j, Nat)) = true
		∀ i,p ∈ {0 ... n1 -1}, ∀ j,k ∈ {0 ... n2 -1}
			if p = i && k = j then :
				nature(setNature(L, i, j, Nat), p, k) = Nat
			else
				nature(setNature(L, i, j, Nat), p, k) = nature(L, p, k)    
                            
      [goPlay] 
      	editing(goPlay(L)) =  ¬(editing(L))
      	nature(goPlay(L),i,j) = nature(L,i,j)	
		∃ y1,y2,y3 consécutifs  ∈ {1 ... height(L)-1} et ∃ x ∈ {1 ... width(L)-1} tq 
		entrance(goPlay(L)) = <x,y2> && nature(goPlay(L),x,y1) = nature(goPlay(L),x,y3) = EMPTY 
		∃ y1,y2,y3 consécutifs ∈ {1 ... height(L)-1} et ∃x ∈ {1 ... width(L)-1} tq 
		onExit(goPlay(L),x,y2) && nature(goPlay(L),x,y1) = METAL && nature(goPlay(L),x,y3) = EMPTY
								
	  [remove]
		editing(remove(L, i, j)) =  editing(L)
		if nature(L,i,j) = DIRTY then :
			nature(remove(L,i,j)) = EMPTY
		else
			nature(remove(L,i,j)) =  nature(L,i,j)
						
	  [build]		
		editing(build(L, i, j)) =  editing(L)
		if nature(L,i,j) = EMPTY then :
			nature(build(L,i,j)) = DIRTY
		else
			nature(build(L,i,j)) =  nature(L,i,j)



	  	 